package com.tpi.teoi;

import java.util.ArrayList;
import java_cup.runtime.*; //para utilizar cup
import java.util.*;
import java.util.List;


 
parser code
{:
	/**METODO AL QUE SE LLAMA AUTOMATICAMENTE ANTE ALGUN ERROR SINTACTICO*/
 	
 	public void sintax(Symbol s){
 		System.out.println("Error en linea la " + (s.right+1) + "columna" +s.left + ". " +
 		s + "no reconocio. valor" + s.value);
 	} 
 :}
 
action code
{:
	MatchProcessorSintactico mps = new MatchProcessorSintactico();
:}



/*DECLARACION DE TERMINALES (TOKEN DEL ANALIZADOR LEXICO) */

terminal 	LETRA, DIGITO, PRIMER_NUMERO, CARACTERES_ESPECIALES, ID, EspacioBlanco, COMMENT_BEG, COMMENT_END, 			COMMENT, CONST_INT, CONST_STRING, CONST_FLOAT, TYPE_INT, TYPE_STRING, TYPE_FLOAT, AND, OR, IGUAL, 			DISTINTO, MAYOR, MAYOR_I, MENOR, MENOR_I, DEC, ENDDEC, START, FINALIZE, IF, WIHILE, TAKE, EXIT, 		ELSE,SIG_MENOS, SIG_MAS, SIG_DIV, SIG_MUL, COMA, PUNTO, PUNTO_Y_COMA, COM, SQR_BRACKET_OPEN, 			SQR_BRACKET_CLOSE, BRACKET_OPEN, BRACKET_CLOSE, KEY_OPEN, KEY_CLOSE, OP_ASSIGN, OP_DECLARE;

/*DECLARACIONES NO TERMINALES (LOS NUESTROS) */

non terminal 	comienzo_programa, declaracion_programa, bloque_definicion, reglon_definicion, inicial, separador, 			final, programa, lista_de_sentencias, sentencia, bloque_condicion, condicion, bloque_sentencias, 		asignacion, iteracion, seleccion, write, expresion, iteracion, comparacion, comparador, termino, 		factor, take, lista_constantes;

/* SE DECLARA POR CUAL COMIENZA */

start  with 	comienzo_programa;

/*BLOQUE DE GLC*/

comienzo_programa ::= declaracion_programa programa {:mps.addString("comienzo_programa Compila correctamente 																				llegando al simbolo start");:};

declaración_programa ::= DEC bloque_definicion ENDDEC {:mps.addString(" Declaracion_programa regla[1]":};

bloque_definicion ::= renglon_definicion {:mps.addString(" bloque_definicion regla[2]":};	

bloque_definicion ::= bloque_definicion renglon_definicion {:mps.addString(" bloque_definicion regla[3]":};	

renglon_definicion	::= inicial separador final {:mps.addString(" renglon_definicion regla[4]":};	

inicial ::= SQR_BRACKET_OPEN ID {:mps.addString(" inicial regla[5]":};	

final ::= TYPE_INT SQR_BRACKET_CLOSE {:mps.addString(" final regla[6]":};	

final ::= TYPE_FLOAT SQR_BRACKET_CLOSE {:mps.addString(" final regla[7]":};	

final ::= TYPE_STRING SQR_BRACKET_CLOSE {:mps.addString(" final regla[8]":};	

separador ::= SQR_BRACKET_CLOSE OP_DECLARE SQR_BRACKET_OPEN {:mps.addString(" bloque_definicion regla[9]":};

separador::= COMA ID separador TYPE_INT COMA | COMA ID separador TYPE_FLOAT COMA | COMA ID separador TYPE_STRING COMA 														{:mps.addString(" separador regla[10]":};

programa ::= START lista_de_sentencias FINALIZE {:mps.addString(" programa regla[11]":};

lista_de_sentencias ::=  sentencia {:mps.addString(" lista de sentencias sentencia regla[12]":};

lista_de_sentencias ::= lista_de_sentencias sentencia {:mps.addString(" lista de sentencias regla[13]":};

bloque_condicion ::= BRACKET_OPEN condicion BRACKET_CLOSE {:mps.addString(" bloque_condicion regla[14]":};

bloque_sentencias ::= SQR_BRACKET_OPEN lista_de_sentencias SQR_BRACKET_CLOSE	{:mps.addString(" bloque_sentencias regla[16]":};

sentencia ::= asignación {:mps.addString(" sentencia regla[17]":};

sentencia ::= iteración {:mps.addString(" senetencia regla[18]":};

sentencia ::= selección{:mps.addString(" sentencia regla[19]":};

asignación ::= ID OP_ASSIGN expresión{:mps.addString(" asignacion regla[20]":};

selección ::= IF bloque_condicion bloque_sentencias{:mps.addString(" seleccion regla[21]":};

selección  ::= IF bloque_condicion bloque_sentencias ELSE bloque_sentencias{:mps.addString("seleccion regla[22]":};

iteración ::= WHILE bloque_condición  bloque_sentencias{:mps.addString(" iteracionregla[23]":};

condición ::= comparación{:mps.addString(" condicion regla[24]":};

condición ::= comparacion AND comparación{:mps.addString(" condicionregla[25]":};

condición ::= comparacion OR comparación{:mps.addString(" condicion regla[26]":};

comparación ::= expresión comparador expresión{:mps.addString(" comparacion regla[27]":};

comparador ::= MAYOR | MAYOR_I | MENOR | MENOR_I | IGUAL | DISTINTO{:mps.addString(" comparador regla[28]":};

expresión ::=  expresión SIG_MAS término | expresión SIG_MENOS termino | termino{:mps.addString("expresion regla[29]":};

termino ::= termino SIG_MUL factor | termino SIG_DIV factor |  factor{:mps.addString(" termino regla[30]":};

factor ::= BRACKET_OPEN expresion BRACKET_CLOSE | ID | CONST_FLOAT | CONST_INT |take{:mps.addString(" factor  regla[31]":};

write ::= WRITE CONST_FLOAT | WRITE CONST_INT | WRITE CONST_STRING | WRITE ID	{:mps.addString("write regla[32]":};

lista_constantes::= lista_constantes COMA CONST_INT | CONST_INT {:mps.addString("lista_constantes regla[33]":};

take::= TAKE BRACKET_OPEN SIG_MAS PUNTO_Y_COMA ID PUNTO_Y_COMA SQR_BRACKET_OPEN{:mps.addString("take regla[34]":};

lista_constantes SQR_BRACKET_CLOSE BRACKET_CLOSE{:mps.addString("lista_constantes regla[35]":};



